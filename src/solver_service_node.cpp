
#include <forces_pro_server/solver_service_node.h>

#include <rclcpp/rclcpp.hpp>

extern "C"
{
    SOLVER_EXT_FUNC ext_func = &my_solver_adtool2forces;
}

// Solver
Solver::Solver()
{
    // Allocate memory
    solver_memory_ = (char *)malloc(SOLVER_GET_MEM_SIZE());
    solver_memory_handle_ = SOLVER_EXTERNAL_MEM(solver_memory_, 0, SOLVER_GET_MEM_SIZE());
}

Solver::~Solver()
{
    free(solver_memory_);
}

int Solver::Solve()
{
    int exit_code = SOLVER_SOLVE(&forces_params_, &forces_output_, &forces_info_, solver_memory_handle_, stdout, ext_func);
    return exit_code;
}

void Solver::SolveServiceCallback(
    const std::shared_ptr<forces_pro_server::srv::CallForcesPro::Request> request,
    std::shared_ptr<forces_pro_server::srv::CallForcesPro::Response> response)
{
    auto logger = rclcpp::get_logger("solver_service");
    RCLCPP_INFO(logger, "Received request to call Forces Pro optimization solver");

    
    // Process the request (resize and add data)
    size_t x0_size = sizeof(forces_params_.x0) / sizeof(*forces_params_.x0);
    for (size_t i = 0; i < x0_size; i++)
        forces_params_.x0[i] = request->x0.data[i];
    // forces_params_.x0 = request->x0.data;

    size_t param_size = sizeof(forces_params_.all_parameters) / sizeof(*forces_params_.all_parameters);
    for (size_t i = 0; i < param_size; i++)
        forces_params_.all_parameters[i] = request->params.data[i];

    size_t xinit_size = sizeof(forces_params_.xinit) / sizeof(*forces_params_.xinit);
    for (size_t i = 0; i < xinit_size; i++)
        forces_params_.xinit[i] = request->xinit.data[i];

    response->exit_code = Solve(); // Solve the optimization problem

    // Fill the response
    /** @todo This should probably be autogenerated depending on what your horizon length is*/
    RCLCPP_INFO(logger, "Solver output: %f %f",forces_output_.x01[0], forces_output_.x01[1]);
    
    size_t j = 0;
    size_t num_var = sizeof(forces_output_.x01) / sizeof(*forces_output_.x01);
    
    /**RCLCPP_INFO(logger, "number var: %d",num_var);*/

    response->output.data.resize((num_var*10));
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x01[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x02[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x03[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x04[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x05[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x06[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x07[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x08[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x09[i];
        j += 1;
    }
    for (size_t i = 0; i < num_var; i++){
        response->output.data[j] = forces_output_.x10[i];
        j += 1;
    }

    RCLCPP_INFO(logger, "Request processed and outputs returned");
}

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    auto solver = std::make_shared<Solver>(); // The solver

    auto node = rclcpp::Node::make_shared("forces_pro_server");

    auto server = node->create_service<forces_pro_server::srv::CallForcesPro>(
        "call_forces_pro",
        std::bind(&Solver::SolveServiceCallback, solver, std::placeholders::_1, std::placeholders::_2));

    RCLCPP_INFO(node->get_logger(), "server started");

    rclcpp::spin(node);

    rclcpp::shutdown();
    return 0;
}